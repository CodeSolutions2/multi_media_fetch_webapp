<!DOCTYPE html>
<html>
<head></head>
<body>

<h1>Multimedia fetch data webapp</h1>
<ol type="A">
	<li>Enter URL.</li>
	<ul>
		<li>Discrete data: https://nominatim.openstreetmap.org/search?q=LOCATION_NAME&format=json</li>
		<li>Time-series data: https://api.open-meteo.com/v1/forecast?latitude=LATITUDE&longitude=LONGITUDE&hourly=temperature_2m</li>
		<li>Image PDF: https://raw.githubusercontent.com/CodeSolutions2/pdf_to_text_webapp/main/document_imagepdf.pdf</li>
		<!-- <li>Text PDF:https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf</li> -->
		<li>Image: https://storage.googleapis.com/on-the-way2selfrespect/yellow.png</li>
	</ul>
	<li>method: 'GET', 'POST'</li>
	<li>data: {}</li>
  	<li>w_or_wo_proxyhandler: w_proxyhandler, wo_proxyhandler</li>
	<li>return_type: json, blob, blob_file_pdf, arrayBuffer, text</li>
	
</ol>
	
<input id="url" type="text" value="" placeholder="url" rows="10" cols="100" style="display:block; text-align: left; width: 600px;">
<input id="method" type="text" value="" placeholder="method" rows="10" cols="100" style="display:block; text-align: left; width: 600px;">
<input id="data" type="text" value="" placeholder="data" rows="10" cols="100" style="display:block; text-align: left; width: 600px;">
<input id="w_or_wo_proxyhandler" type="text" value="" placeholder="w_or_wo_proxyhandler" rows="10" cols="100" style="display:block; text-align: left; width: 600px;">
<input id="return_type" type="text" value="" placeholder="return_type" rows="10" cols="100" style="display:block; text-align: left; width: 600px;">
	
<button id="run_fetch_CORS" onclick="run_fetch_CORS()">run_fetch_CORS</button>
	
<button id="run_jQuery_CORS" onclick="run_jQuery_CORS()">run_jQuery_CORS</button>

<button id="get_forecast_temperature_data" onclick="get_forecast_temperature_data()">get_forecast_temperature_data</button>
	
	
<!-- <script src='https://code.jquery.com/jquery-3.6.3.min.js'></script> -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>


<script>
	
// -----------------------------------------------
	
window.addEventListener('beforeunload', function() {
    window.location.href = window.location.href + '?nocache=' + new Date().getTime();
});
	
// -----------------------------------------------

async function run_fetch_CORS() {

	var url = document.getElementById('url').value;  // url: url address
	var method = document.getElementById('method').value;  // method: 'GET', 'POST'
	var data = document.getElementById('data').value;  // data: required data format for url address
	var w_or_wo_proxyhandler = document.getElementById('w_or_wo_proxyhandler').value;  // w_or_wo_proxyhandler: 'w_proxyhandler', 'wo_proxyhandler'
	var return_type = document.getElementById('return_type').value;  // return_type: 'json', 'blob', 'blob_file_pdf', 'arrayBuffer', 'text'

	var data = await fetch_CORS(url, method, data, w_or_wo_proxyhandler, return_type);
	console.log('data: ', data); 
}

// -----------------------------------------------

async function run_jQuery_CORS() {

	var url = document.getElementById('url').value;  // url: url address
	var method = document.getElementById('method').value;  // method: 'GET', 'POST', 'PUT'
	var data = document.getElementById('data').value;  // data: required data format for url address
	var return_type = document.getElementById('return_type').value;  // return_type: 'json', 'blob', 'blob_file_pdf', 'arrayBuffer', 'text'

	var data = await  jQuery_CORS(url, method, data, return_type);
	console.log('data: ', data); 
}
	
	
// -----------------------------------------------
	
async function get_forecast_temperature_data(url) {
	
	// [Step 0] Get latitude and longitude
	var url = 'https://nominatim.openstreetmap.org/search?q=Lyon&format=json';
	var method = 'GET';  // method: 'GET', 'POST'
	var data = [];  // data: required data format for url address
	var w_or_wo_proxyhandler = 'w_proxyhandler';  // w_or_wo_proxyhandler: 'w_proxyhandler', 'wo_proxyhandler'
	var return_type = 'json';  // return_type: 'json', 'blob', 'blob_file_pdf', 'arrayBuffer', 'text'
	var out = await fetch_CORS(url, method, data, w_or_wo_proxyhandler, return_type);
	console.log('out: ', out); 

	// --------------------------------

	var latitude = out[0].lat;
	var longitude = out[0].lon;
	console.log("latitude: ", latitude);
	console.log("longitude: ", longitude);

	// [Step 0] Get weather data
	// https://open-meteo.com/en/docs
	// The API endpoint /v1/forecast accepts a geographical coordinate, a list of weather variables and responds with a JSON hourly weather forecast for 7 days. Time always starts at 0:00 today and contains 168 hours. If &forecast_days=16 is set, up to 16 days of forecast can be returned. All URL parameters are listed below:

	url = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&hourly=temperature_2m`;
	
	method = 'GET';  // method: 'GET', 'POST'
	w_or_wo_proxyhandler = 'w_proxyhandler';  // w_or_wo_proxyhandler: 'w_proxyhandler', 'wo_proxyhandler'
	return_type = 'json';  // return_type: 'json', 'blob', 'blob_file_pdf', 'arrayBuffer', 'text'
	out = await fetch_CORS(url, method, data, w_or_wo_proxyhandler, return_type);
	console.log('out: ', out);
	
}

// -----------------------------------------------
	

	

// -----------------------------------------------
// SUBFUNCTIONS
// -----------------------------------------------

async function fetch_CORS(url, method, data, w_or_wo_proxyhandler, return_type) {

	// url: url address
	// method: 'GET', 'POST'
	// data: required data format for url address
	// w_or_wo_proxyhandler: w_proxyhandler, wo_proxyhandler
	// return_type: json, blob, blob_file_pdf, arrayBuffer, text

	// --------------------------------

	// Determine request method
	var headers = {
		"Content-Type": "application/json",
		"Referer": url,
		"Origin": "https://codesolutions2.github.io",
		"Connection": "keep-alive",
		//"Sec-Fetch-Dest": "empty",
		//"Sec-Fetch-Mode": "cors", 
		//"Sec-Fetch-Site": "cross-site",
		//"Sec-Fetch-User": "?1",
		"User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:120.0) Gecko/20100101 Firefox/120.0",
		"Access-Control-Allow-Origin": "*",
		//'Access-Control-Allow-Credentials': false, 
		//"Access-Control-Request-Method": method,
		//"Access-Control-Request-Headers": 'content-type,x-pingother',
		//'Cache-Control': 'max-age=0',
	};
	
	var options = { 
		method : method,
		mode: 'cors',
		headers: new Headers(headers),
		cache: "no-cache",
		// crossorigin: 'anonymous',
		crossorigin: '*',
		redirect: "follow"
	};

	if (method == 'POST') {
		options.body = JSON.stringify(data);
	}

	// --------------------------------

	// Determine the type of output to return 
	
	if (return_type == 'json') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			const proxy3 = await define_proxy_handler();
			return await proxy3(url, options)
				.then(response => response.json())
				.then(async function(data) { console.log('data: ', data); return data; })
				.catch(error => console.error("error: ", error));
		} else { 
			return await fetch(url, options)
				.then(response => response.json())
				.then(async function(data) { console.log('data: ', data); return data; })
				.catch(error => console.error("error: ", error));
		}
		
	} else if (return_type == 'blob') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			const proxy3 = await define_proxy_handler();
			return await proxy3(url, options)
				.then(response => response.blob())
				.then(async function(blob_object) { console.log('blob_object: ', blob_object); return blob_object; })
				.catch(error => console.error("error: ", error));
		} else {
			return await fetch(url, options)
				.then(response => response.blob())
				.then(async function(blob_object) { console.log('blob_object: ', blob_object); return blob_object; })
				.catch(error => console.error("error: ", error));
		}
		
	} else if (return_type == 'blob_file_pdf') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			const proxy3 = await define_proxy_handler();
			return await proxy3(url, options)
				.then(response => response.blob())
				.then(async function(blob_object) { 
					console.log('blob_object: ', blob_object);
					return new File ([blob_object], "file_download", {type: "application/pdf"});
				})
				.then(async function(file_blob_object) {
					console.log('file_blob_object: ', file_blob_object);
					let github_url_of_externally_downloaded_data = URL.createObjectURL(file_blob_object);
					console.log('github_url_of_externally_downloaded_data: ', github_url_of_externally_downloaded_data);
					await show_pdf_on_page(github_url_of_externally_downloaded_data);

					// a file was loaded before, so remove the blob URL from memory to use resources effectively
					// URL.revokeObjectURL(github_url_of_externally_downloaded_data);
					await setTimeout(function() { URL.revokeObjectURL(github_url_of_externally_downloaded_data); }, 200);
					
					return "File blob loaded with success";
				})
				.catch(error => console.error("error: ", error));
		} else {
			return await fetch(url, options)
				.then(response => response.blob())
				.then(async function(blob_object) { 
					console.log('blob_object: ', blob_object);
					return new File ([blob_object], "file_download", {type: "application/pdf"});
				})
				.then(async function(file_blob_object) {
					console.log('file_blob_object: ', file_blob_object);
					let github_url_of_externally_downloaded_data = URL.createObjectURL(file_blob_object);
					console.log('github_url_of_externally_downloaded_data: ', github_url_of_externally_downloaded_data);
					await show_pdf_on_page(github_url_of_externally_downloaded_data);

					// a file was loaded before, so remove the blob URL from memory to use resources effectively
					// URL.revokeObjectURL(github_url_of_externally_downloaded_data);
					await setTimeout(function() { URL.revokeObjectURL(github_url_of_externally_downloaded_data); }, 200);
					
					return "File blob loaded with success";
				})
				.catch(error => console.error("error: ", error));
		}
		
	} else if (return_type == 'arrayBuffer') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			const proxy3 = await define_proxy_handler();
			return await proxy3(url, options)
				.then(response => response.arrayBuffer())
				.then(async function(arraybuffer) { console.log("arraybuffer:", arraybuffer); return blob_object; })
				.catch(error => console.error("error: ", error));
		} else {
			return await fetch(url, options)
				.then(response => response.arrayBuffer())
				.then(async function(arraybuffer) { console.log("arraybuffer:", arraybuffer); return blob_object; })
				.catch(error => console.error("error: ", error));
		}
		
	} else if (return_type == 'text') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			const proxy3 = await define_proxy_handler();
			return await proxy3(url, options)
				.then(res => res.text())
				.then(str_data => { console.log('str_data: ', str_data); return str_data; })
				.catch(error => console.error("error: ", error));
		} else {
			return await fetch(url, options)
				.then(res => res.text())
				.then(str_data => { console.log('str_data: ', str_data); return str_data; })
				.catch(error => console.error("error: ", error));
		}
	}

	// --------------------------------
}


async function define_proxy_handler() {
	// Parameters to influence Response Header
	// The `handler` object defines a `apply` method that intercepts the `fetch` function calls and adds the "Access-Control-Allow-Origin" header with a value of "*" to the request options. The `new Proxy(fetch, handler)` creates a proxied version of the `fetch` function that applies the defined handler.
	// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers
	const handler = {
		apply: function(target, thisArg, args) {
			// One needs to re-define the input arguments of the handler because a constant variable is used as a function (ie: await proxy3(url, options))
			const [url, options] = args;
			if (options && options.headers) {
				options.headers['Access-Control-Allow-Origin'] = '*';
				options.headers['Access-Control-Allow-Credentials'] = false;
				options.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE';
				// options.headers['Access-Control-Allow-Headers'] = 'Origin, X-Requested-With, Content-Type, Accept';
				options.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization';
				options.headers['Access-Control-Max-Age'] = 0;
			} else {
				args[1] = {
					headers: { 
						'Access-Control-Allow-Origin': '*',
						'Access-Control-Allow-Credentials': false,
						'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE',
						'Access-Control-Allow-Headers': 'Content-Type, Authorization',
						'Access-Control-Max-Age': 0
					}
				};
			}
			// console.log('args: ', args);
			return Reflect.apply(target, thisArg, args);
		}
	};

	// Proxy sturcture works! 
	// Calls the function WITHOUT input variables to assign a proxy definition to a constant variable. 
	// The constant variable is called as a function, where it resolves promises. 
	// Call the constant variable proxy3 as a function to resolve the promise correctly
	return await new Proxy(fetch, handler);
}

// -----------------------------------------------
	
async function jQuery_CORS(url, method, data, return_type) {

	// https://api.jquery.com/jQuery.ajax/
	
	// url: url address
	// method: 'GET', 'POST', 'PUT'
	// data: required data format for url address
	// return_type: json, blob, blob_file_pdf, arrayBuffer, text

	var headers = {
		"Accept": "application/json",
		"Referer": url,
		"Origin": "https://codesolutions2.github.io",
		"Connection": "keep-alive",
		//"Sec-Fetch-Dest": "empty",
		//"Sec-Fetch-Mode": "cors", 
		//"Sec-Fetch-Site": "cross-site",
		//"Sec-Fetch-User": "?1",
		"User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:120.0) Gecko/20100101 Firefox/120.0",
		"Access-Control-Allow-Origin": "*",
		//'Access-Control-Allow-Credentials': false, 
		//"Access-Control-Request-Method": method,
		//"Access-Control-Request-Headers": 'content-type,x-pingother',
		//'Cache-Control': 'max-age=0',
	};
	
	var settings = {
		// url: url,
		type : method,
		dataType: 'json', // data type response format: 'xml', html, script, json, jsonp, text
		async: true,
		crossDomain: true,
		beforeSend: function(xhr) {xhr.withCredentials = true;},
		// headers: new Headers(headers),
		success: function(response) { console.log('Success'); },
		error: function(xhr, status, error) { console.log('Error:', error); }
	};

	// --------------------------------
	
	if (method == 'POST') {
		settings.body = JSON.stringify(data);
	}

	// --------------------------------

	// Determine the type of output to return 
	
	if (return_type == 'json') {
		// settings.xhrFields.responseType = 'json';
		// OR
		settings.xhrFields = {responseType: 'json'};

		return $.ajax(url, [,settings])
			.done(function(response) { console.log('response: ', response); return response; });
		
	} else if (return_type == 'blob') {
		// settings.xhrFields.responseType = 'blob';
		// OR
		settings.xhrFields = {responseType: 'blob'};

		var text_pdf = await $.ajax(url, [,settings]).done(function(response) { console.log('response: ', response); return response; });

		text_pdf.split()
										       
		var blob_object = new Blob([text_pdf], {type:"application/pdf"});
		// var blob_object = new Blob([text_pdf], { type: 'application/octet-stream' });
		console.log('blob_object: ', blob_object);
		return blob_object;
		
	} else if (return_type == 'blob_file_pdf') {
		settings.xhrFields = {responseType: 'blob'};

		var jquery_blob = await $.ajax(url, [,settings]).done(function(response) { console.log('response: ', response); return response; });

		// Convert the jquery_blob to a string
		var text_pdf = jquery_blob.toString();
		console.log('text_pdf: ', text_pdf);
		
		var blob_object = new Blob([text_pdf], {type:"application/pdf"});
		// var blob_object = new Blob([text_pdf], { type: 'application/octet-stream' });
		console.log('blob_object: ', blob_object);
		
		// var file_blob_object = new File ([blob_object], "file_download", {type: "application/pdf"});
		// console.log('file_blob_object: ', file_blob_object);
		// let github_url_of_externally_downloaded_data = URL.createObjectURL(file_blob_object);
		let github_url_of_externally_downloaded_data = URL.createObjectURL(blob_object);
		console.log('github_url_of_externally_downloaded_data: ', github_url_of_externally_downloaded_data);
		
		await show_pdf_on_page(github_url_of_externally_downloaded_data);
	
		// a file was loaded before, so remove the blob URL from memory to use resources effectively
		await setTimeout(function() { URL.revokeObjectURL(github_url_of_externally_downloaded_data); }, 200);
		
		return "File blob loaded with success";
		
	} else if (return_type == 'arrayBuffer') {
		// settings.xhrFields.responseType = 'arrayBuffer';
		// OR
		settings.xhrFields = {responseType: 'arrayBuffer'};

		return $.ajax(url, [,settings])
			.done(function(response) { console.log('response: ', response); return response; });
		
	} else if (return_type == 'text') {
		// settings.xhrFields.responseType = 'text';
		// OR
		settings.xhrFields = {responseType: 'text'};

		return $.ajax(url, [,settings])
			.done(function(response) { console.log('response: ', response); return response; });
	}

	// --------------------------------
	
  	// return $.ajax(settings).done(function(response) { console.log('response: ', response); return response; });
	
}

// -----------------------------------------------

async function show_pdf_on_page(file_download_url_name) {

 	var objectElement = document.createElement('object');
  	objectElement.setAttribute("id", "pdf_object_element");
  	objectElement.setAttribute("type", "application/pdf");
  	objectElement.setAttribute("width", 800);
  	objectElement.setAttribute("height", 1200);
  	objectElement.setAttribute("data", file_download_url_name);
  	document.getElementsByTagName('body')[0].appendChild(objectElement);
}

// -----------------------------------------------

async function automatically_download(file_download_url_name) {

 	var link = document.createElement('a');
 	link.href = file_download_url_name;  // link.href = canvas.toDataURL("image/png");
 	link.download = file_download_url_name.split('/').pop();
 	link.click();
}

// -----------------------------------------------
	
</script>

  
</body>
</html>
